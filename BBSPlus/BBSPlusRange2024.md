# VC Proof Type based on Zero-knowledge Proofs

## Abstract

This document describes an embedded proof type, applicable for Verifiable Credentials, as described in the [Verifiable Credentials Data Model](https://w3c.github.io/vc-data-model/)'s ["Proofs" section](https://w3c.github.io/vc-data-model/#proofs-signatures) by the W3C Credentials Community Group.

## Status of this Document
This specification by NTT DATA is an unofficial draft. It is provided as a reference for people and organisations who wish to implement Ethereum-based proofs.

## Introduction

The Verifiable Credentials specification [describes](https://w3c.github.io/vc-data-model/#proofs-signatures) a modular mechanism for declaring how a given credential must be verified.

This specification introduces a new type of embedded proof called "BBSPlusRange2024". This VC proof is based on zero-knowledge range proofs derived from a message signed with the BBS+ cryptographic suite.

This document builds on top of the [Verifiable Credentials specification](https://w3c.github.io/vc-data-model/) and assumes that the terminology and concepts of that specification are known.

This proof type can be used in zero-knowledge proof scenarios. Such scenarios are useful when the holder of an original VC needs to generate a second VC derived from that original VC, with less specific information. The particularity of such derived VCs is that even though their issuer is the same as the original VC's, the derived VC itself is actually created by the holder. When that happens, the holder is called "prover".

## Specification

A BBSPlusRange2024 proof is represented by an object contained in the `"proof"` section of a Verifiable Credential. As such, per the VC Data Model, it is considered an "embedded proof".

It must contain the following attributes:

<dl>
  <dt>type</dt>
  <dd>The proof type, as defined in the Verifiable Credentials specification. The value MUST be <code>"BBSPlusRange2024"</code>.</dd>
  <dt>label</dt>
  <dd>The BBS+ label. It must be constructed as JSON array in the following form: \["Type","attribute1",...,"attributeN"\], serialized as string.</dd>
  <dt>proofValue</dt>
  <dd>The content of the proof generated by the holder.</dd>

</dl>

## Transforming an original VC into a derived VC

In ZKP scenarios, the Prover is the one generating the derived VC from the information present in the original VC. Thus, the Prover would be the technical "author" of the derived VC. However, the issuer of the original VC is also the "issuer" of the derived VC, since the assertion still comes from them, and can be trusted as such.

To convert a numeric value into a Range Proof for a given claim, the Prover must keep the same claim name but must replace the numeric value with an object containing a `min` and a `max` attribute.

The "claims" attribute must be the exact same as in the original VC.

## Example

```json
{
  "@context": [
    "https://www.w3.org/2018/credentials/v1"
  ],
  "type": [
    "VerifiableCredential"
  ],
  "credentialSubject": {
    "id": "did:example:123",
    "birthDate": {
      "min": 762365700,
      "max": 762365800
    }
  },
  "issuer": "did:example:456",
  "issuanceDate": "2024-02-13T14:39:29.693Z",
  "proof": {
    "type": "BBSPlusRange2024",
    "label": "Some label",
    "claimIndex": {
      ".issuanceDate": 0,
      ".expirationDate": 1,
      "id": 2,
      "birthDate": 5
    },
    "proofValue": "AgAAAAAAAAAAt0r9ej3XSw_CYpRqGEKO7tSu_XTnw9-X8Czp5Lg4AkHFJ_VQJWlyBG5b7Cecl582tSQhaggQ0ep9Hghrm0JwxxnAd1nygtX0TMR0KPA1WvcvYpy1bKOZLre_TsFotuuDov3XEGB6D7ZqGlZhd3dV1oFLUanTlR38-IgwaRyMwGd_kXpA7Pwnmq7lJtG2L3OYry9HEphoF691oFjH1SLsUtVt0jzgbd4tSy5HlV7c6iqvlpMV26rUp3lbznk5TMTKAgAAAAAAAABZ0e1DcbuZSQ-ojrvkBIC7YHL-VNbEmVuvX99yQmYoVXydCxTZBCgBReFAkqrf9uwNmRVtjakKYEGow6wvQ948kI6WyFKgOBy5YPlQXGYQj43BOQAuXj80D17v1HUSTWga9-xB9Gq86mYLrG6M8bP_AwAAAAAAAACTzd52xwKqD09kz6Hgbwu7oqiMv6O2k5yJ854YxFjQXjO-YpEMzPB-KZtZZkuoJGbTXQkd7pNu6zp42F9c04Vto7402kihd2puGFt6VE3Ui8M2ekj1tuGQxLbKhIUcj1gFq3lqR4ZVZ2sMMUslGw7tuxafkwKARiDWXxqdNPVsOxakjEU1Ma_h9jBa0rQ_RoscqnWrzHP0DzZgax0kyWztu5I4pdbsWgzZlWP1jLf9jXmBj7wjCgPb2rvUZxjihciCGPVbDoJMKuKOVtfFUzbGnur5vZsI1swhBXr4jG5xHDvIb8dsE9Kpk-2frWQVFlhgg8YbSLu5Xm1hWhdqoUcPvJ_AzvjyRLYfLxnx_6T5J_E7xWheWNM6FEEjijPu7KsXhSZwjpO7VRv0mbAZKC94aoLxItygDiiBq2utUK9TKk2Tdap-JAx3Lcp-16Lml4yDrPAHxqVuRi_W8j58t4UbunhBQwYMbWbo9zBOoaI93kimW70dFJrUn21-FYK6ncLVAgAAAAAAAACjvjTaSKF3am4YW3pUTdSLwzZ6SPW24ZDEtsqEhRyPWGzB9JJRnwSy3eFkppzAbB3ghRXxaIylA3NULF_5oEhkAAAAAQAAAAAAAAABAAAAAAAAALh_HDpIoFGvv8kox2KpjQHUBMu-dQCQzjvJL-EUgswm"
  }
}
```

## Proof Generation Steps (Prover)

1. Decide what claims, from the original VC's list of claims (in the proof object), are to be revealed in the derived VC.
2. Create a "claimIndex" object in the derived VC's proof object, with the chosen claims and their respective indexes in the original list.
2. Create the "credentialSubject" content with the chosen claims' keys and values.
3. Replace the numeric values with ranges wherever needed.
4. Generate the proof from the original signature, new values, and claim index object.

## Proof Verification Steps (Verifier)

1. Following the order of claims in the proof object's claim index, and the values present in the VC, generate a list of messages in the form ["key1", "value1", "key2", "value2", ...]. Note that this message list must take into account the index of each message.
2. Decode the signature as base64 and verify the message list against the signature.

# Algorithms

## createBBSPlusRange2024Proof

The following algorithm creates a BBSPlusRange2024 proof object for a derived verifiable credential. The required inputs are:

- A verified credential with a `BBSPlus2024` proof type, required fields `issuanceDate`, `credentialSubject` and an optional field `expirationDate`. This will be refered as the original credential.
- A base 64 url encoded`provingKey` provided by the verifier.
- A presentation definition that includes:
  - The claim which value the verifier wants to test against a range.
  - A predicate future for the claim with integers `minimum` and `exclusiveMaximum` for the specified claim.
  - Optionally, other claims to be revealed, such as `credentialSubject.id`, or fields such as `issuanceDate`or `expirationDate`

1. Using the original credential, the prover derives the public parameter `label` from `proof.label` and `messageCount` from `proof.claims`. In the case of `messageCount`, its value should double the one from `proof.claims` length.
2. The `messages` list is rebuilt from the original credential and the `proof.claims` order (see `createBBSPlus2024Proof`).
3. Using the requirements of the presentation definition, the proving key and the `messages` list, the prover constructs a proof by alternating between selective disclosure and bound range proof:
    1. If `credentialSubject.id`, `issuanceDate`or `expirationDate` are requested, selective disclosure is applied on their respective even (name claim) and odd (value) indexes.
    2. For the range proof, selective disclosure is applied on the claim even index and the  bound range statement is applied on the odd index.
4. Generate `proof` object with `type`, `sig`, `claimIndex` and `claimCount` properties.
    1. `type` is always "BBSPlusRange2024".
    2. `label` is the public parameter on `proof.label` from the original credential.
    3. `claimCount` is the number of elements on `proof.claims` from the original credential.
    4. `claimIndex` is an object that indicates the index of the fields claims revealed or which a range proof was applied to. Currently, `issuanceDate`, `expirationDate` and `credentialSubjec.id` (optionally) are the only fields and values that could be revealed, besides the range claim name. Indexes are based on `proof.claims` from the original credential.
    5. `proofValue` is the base 64 url encoded proof.

Example of `proof` object:

```json
"proof": {
    "type": "BBSPlusRange2024",
    "label": "Some label",
    "claimIndex": {
      ".issuanceDate": 0,
      ".expirationDate": 1,
      "id": 2,
      "birthDate": 3
    },
    "claimCount": 4,
    "proofValue": "AgAAAAAAAAAAt0r9e...-dQCQzjvJL-EUgswm"
}
```

## verifyBBSPlusRange2024Proof

The following algorithm verifies a BBSPlusRange2024 proof returning a boolean as a result. The required inputs are:

- A derived credential with a `BBSPlusRange2024` proof type, with the fields requested on the verifier presentation definition.
- The `provingKey` shared to the prover.
- The presentation definition that includes:
  - The claim which value the verifier wants to test against a range.
  - A predicate future for the claim with integers `minimum` and `exclusiveMaximum` for the specified claim.
  - Properties `issuanceDate` or `expirationDate` to be revealed
  - Optionally, the `credentialSubject.id` claim to be revealed

1. Using the derived credential, the verifier builds the public parameter `label` from `proof.label` and `messageCount` from `proof.claimCount`. In the case of `messageCount`, its value should double the one from `proof.claimCount`.
3. Using the requirements of the presentation definition, the proving key and the indexes from `proof.claimIndex`, the verifier constructs a proof verifier by alternating between selective disclosure and bound range proof:
    1. Selective disclosure is applied to `issuanceDate`, `expirationDate` and `credentialSubject.id` (optional), based on the normalized indexes from `proof.claimCount`. In order to normalize the indexes, you transform them to the form `2*i` for the even (claim name) and `2*i+1` odd (value) in order to match the indexes on the original message list signed.
    2. For the range proof, selective disclosure is applied on the claim even index and the bound range statement is applied on the odd index, you should normalize the `proof.claimCount` index the same as above.
4. The verifier applies the proof verifier to see if the actual proof was correct.

